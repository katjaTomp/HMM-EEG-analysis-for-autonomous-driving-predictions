import numpy as np
import pandas as pd
import os
from sklearn.externals import joblib

import matplotlib

matplotlib.use('TkAgg')
matplotlib.interactive(False)
from matplotlib import cm, pyplot as plt
import pickle

data_location = "folder"  # this is the folder where data generated by EegPreprocessor.py resides


# all_events = ["65304","65306","65308","65281","65284","65286","65288","65298","65296","65294"]

def getEvents(ppn):

    epochs_time_events = pickle.load(open("ppn" + str(ppn) + "_events")) # these were created in loadData_times.py
    return epochs_time_events


def loadData(electrode="FCz"):
    """
    This function prepares the data for training.
    If no  electrode is defined the FCz electrode's values are only considered

    :param electrode: string which can be any valid electrode name
    :return: list of vectors containing from an electrode
    """

    frontal = []

    filenames = [f for f in os.listdir(data_location) if f.endswith('.pkl')]

    frontal_final = [np.array(pd.read_pickle(filename)[electrode]).reshape(-1, 1) for filename in filenames[:-2]]

    participant_19 = np.concatenate(
            [np.array(pd.read_pickle(filename)[electrode]).reshape(-1, 1) for filename in filenames[-2:]])

    frontal_final.append(participant_19)

    file_lengths = [len(x) for x in frontal_final]

    return [frontal_final, file_lengths]


def get_ModelInfo(model, X):
    """
    Retrieves the information from the model
    :param model: learned HMM model
    :param X: vectors of data
    :return: mean, covariance and transitional probabilities matrix
    """

    A = model.transmat_
    means = model.means_
    # pi = model.startprob_
    # B = model.predict_proba(X)
    covars = model.covars_

    return means, covars, A


def get_300after_stimulus(events, seq_states):
    """
    This function retrieves only 300 ms after stimulus for my analysis

    :param events: events data
    :param seq_states: decoded sequences of predicted states
    :return:  Dataframe containing only event, time and state information
    """

    prev_epoch = -1
    df = pd.DataFrame(columns=['event', 'time', 'state'])
    entry = 0
    offset = 20
    for [epoch, time, event] in events:
        if epoch != prev_epoch:
            if time == 0:
                t = 0

                if (epoch == 0):
                    # print epoch,event, seq_states[60:80]

                    for state in seq_states[20:80]:
                        data = [event, t, state]
                        df.loc[entry] = data

                        t += 1
                        entry += 1

                else:
                    # print epoch,event,offset, seq_states[offset+60:offset+80]
                    for state in seq_states[offset + 60:offset + 80]:  # 60 account to 300 ms
                        data = [event, t, state]
                        df.loc[entry] = data

                        t += 1
                        entry += 1

                prev_epoch = epoch

        offset += 1

    return df


def get_100before_Epoch(events, seq_states):
    """
    This function retrieved data 100 ms before the stimulus onset

    :param events:
    :param seq_states:
    :return:
    """

    prev_epoch = -1
    df = pd.DataFrame(columns=['event', 'time', 'state'])
    entry = 0
    offset = 0
    print events.shape

    for [epoch, time, event] in events:

        if epoch != prev_epoch:
            if time == 0:
                t = 0
                if epoch == 0:

                    for state in seq_states[0:20]:
                        df.loc[entry] = [event, t, state]
                        # print df
                        t += 1
                        entry += 1

                else:
                    for state in seq_states[offset - 20:offset]:
                        df.loc[entry] = [event, t, state]
                        t += 1
                        entry += 1

                prev_epoch = epoch

        offset += 1
    print 'klaar'
    return df


def get_participants(divide=False, condition='all'):
    """
    If divide is True then the participants are divided into groups of high susceptibility and low susceptibility
    :param divide:
    :return: participants indices
    """
    if condition == 'all':
        if divide:
            participants_high = [1, 2, 9, 11, 15, 16, 17, 19]

            participants_low = [3, 4, 5, 6, 7, 10, 12, 13, 14, 18]

            participants = {1: participants_high, 2: participants_low}
        else:

            participant = [1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

            participants = {3: participant}

        return participants

    elif condition == 'driving':

        participants_high = [1, 2, 6, 9, 11, 16, 17]
        participants_low = [3, 4, 5, 7, 10, 12, 13, 14, 15, 18, 19]

        return {1: participants_high, 2: participants_low}

    elif condition == 'autonomous':
        participants_high = [7, 9, 11, 14, 15, 17]
        participants_low = [1, 2, 3, 4, 5, 6, 10, 12, 13, 16, 18, 19]

        return {1: participants_high, 2: participants_low}

    else:
        participants_high = [1, 2, 9, 11, 13, 15, 16, 17, 19]
        participants_low = [3, 4, 5, 6, 7, 10, 12, 14, 18]

        return {1: participants_high, 2: participants_low}


data = loadData( electrode="Fp1")

X, lengths = data[0], data[1]
# Make sure to define below your model which was obtained after running Train_models.py script
# FCz ->"model_3_200.pkl"
model = 'model_4fp1_200.pkl'

model = joblib.load(open(model, 'r'))
means, covars, A = get_ModelInfo(model, X)
print means, covars
for a in A:
    print a[0], a[1], a[2]  # ,a[3],a[4]

df_main = pd.DataFrame(columns=['event', 'time', 'state'])

data = loadData(electrode="Fp1")
condition = 'driving'  # can have values: all, driving, autonomous,stationary
timing = 'before'  # can have before or after value
participants = get_participants(False, condition)

for key, ppn_list in participants.iteritems():
    for i in ppn_list:
        print i
        if i < 9:
            X, lengths = data[0][i - 1], data[1][i - 1]
            events = getEvents(i)

        else:
            X, lengths = data[0][i - 2], data[1][i - 2]

            events = getEvents(i)

        if len(events) != len(X):
            print "Wrong lengths!"
            break

        # decode the sequences
        sequence_of_states = model.predict(X)

        if timing == 'before':

             df = get_100before_Epoch(events, sequence_of_states)
        else:

            df = get_300after_stimulus(events, sequence_of_states)


        df_main = df_main.append(df)

    # to change the names accordingly
    if key == 1:
        pickle.dump(df_main, open('dataFrame_High_4_FP1_High_'+timing + condition, 'w'))
    elif key == 2:
        pickle.dump(df_main, open('dataFrame_Low_4_FP1_Low_'+timing + condition, 'w'))
    else:
        pickle.dump(df_main, open('dataFrame_ALL_4_FP1_'+timing, 'w'))
